We define TSL v2 syntax in two steps.  First, we define basic TSL 
syntax that does not support modules.  Next we define full TSL 
that add support for module composition and inheritance to basic 
TSL.

The following description only describes features necessary for 
modelling software components of the system (the OS and the 
driver), and hardware components written C-based HDLs (e.g., DML).  
Support for Verilog-style HDLs is coming soon.


Basic TSL
=========

Templates
---------

A specification in basic TSL consists of a single template that 
describes the complete system, including, the driver, the device, 
and the OS.

//------------------------------
template my_template
/* type declarations */
/* variable declarations */
/* process declarations */
/* task declarations */
/* function declarations */
/* goal declarations */
endtemplate
//------------------------------


Type declarations
-----------------

Type system similar to TSL1: fixed-size ints, bools, structs, arrays.

//------------------------------
typedef int<20> baud_t;
//------------------------------

Type declarations can appear in top-level and template scopes


Variables
---------

Variables can be declared anywhere inside the template, process, 
function or task.  

A variable can have an "invisible" attribute.  Variables that 
don't have this attribute can only be modified by visible 
transitions (see below).  This attribute does not increase the 
expressive power of the language, but prevents accidental misuse 
of variables.  

//------------------------------
baud_t baud;
invisible baud_t dev_baud;
int<20> x;
int<20> xs[20];
//------------------------------

Processes
---------

A template can contain one or more processes.  Every state 
transition of the system occurs in the context of a single 
process, i.e., only one process can perform a transition at a 
time.  Processes become runnable as soon as the template is 
instantiated.

The body of a process is a statement.  Types of statements: 
variable assignment, sequential block, parallel block, 
non-deterministic choice, termination, loop, etc.  (see below).

//------------------------------

template my_template

process os_model {
    // start of transition 1
    x = 0; 
    y = x; 
    // implicit end of transition before choice
    choice {
        // subprocess 1
        {
            ret = drv_probe(); 
            if (ret != 0) {
                // os_model process terminates
                stop;
            };
            // end of transition 2
        };
        // subprocess 2
        {
            forever {
                drv_set_baud(*);
            };               
        };
    };
    
}

end template

//------------------------------


Assignments
-----------

Assignments have C-style semantics.  An assignment completes 
instantaneously.  Multiple assignments can be performed in a 
single transition.  Multiple assignments to the same variable as 
converted to SSA form by replacing intermediate assignments with 
assignments to temporary variables.

pause
-----

The pause statement terminates previous transition.  It is likely 
to be of limited use, as other means of starting a new transition 
without an explicit pause are likely to be more sufficient in most 
situations (see below)

//------------------------------

process my_process {
    x = 0;
    y = x;
    pause;
    
}

//------------------------------

choice
------

The choice process performs non-determinictic choice between several 
subprocesses.  Given three processes P1, P2, and P3:

P1:
->o--a-->o

P2:
->o--b-->o

P3:
->o--c-->o

process {P1; choice{P2;P3}} behaves as follows:
           --b--
          /     \
->o--a-->o       ->o
          \     /
           --c--

i.e., the last action of process P1 is followed by the first 
action of one of the processes P1 and P2.  

Note that the choice operator implicitly terminates the precedding 
transition.  For example:

//------------------------------
process my_process {
    x = 0;
    y = x;
    choice {
        {x = 2};
        {y = 0};
    };
}
//------------------------------

The first two assignments are performed automically.  The 
following assignment (x=2) or (y=0) is performed in a separate 
transition.

fork
----

The fork process defines (interleaved) parallel composition of two 
or more processes.  The fork process terminates when all forked 
processes terminate.  For example, given processes P1, P2, and P3:

P1:
->o--a-->o

P2:
->o--b-->o

P3:
->o--c-->o

process {P1; fork{P2;P3}} behaves as follows:

           --b-->o--c--
          /            \
->o--a-->o              ->o
          \            /
           --c-->o--b--


Note that fork cannot be used to create an unbounded number of 
processes, e.g., it cannot be used inside a loop with variable 
bounds.  

Similar to choice, fork terminates the preceding transition.  


stop
----

The stop statement terminates either the top-level process or the 
innermost forked or forever process.  By default, a process 
terminates after performing its (syntactically) last action.  stop 
allows teminating the process at any time.

stop does not represent a transition, but rather a state marker 
that marks a final state of the process.  For example:

//------------------------------
process my_process {
    ret = drv_probe();
    if (ret != 0)
        stop;
    drv_send();
}
//------------------------------

Assume that the drv_probe task consists of a single transition.  
Then the above process has the following transition relation.

    --drv_probe(ret!=0)-->(F)
   /
->o
   \
    --drv_probe(ret==0)-->o--drv_send-->o--...-->

where (F) denotes a final state.  

A fork process reaches a final state once each of the forked 
processes is in a final state.  For example, the following process 
forks two subprocesses.  The first performs a non-deterministic 
choice between executing action "a" or terminating immediately.  
The second subprocess performs action "b".  

//------------------------------
process my_process {
    fork{
        choice {
            a;
            stop;
        };
        b;
    };
    c;
}
//------------------------------

Here, the transition relation of the choice{..} process is:

-->(F)--a-->(F)

i.e., both the initial state and the state after action "a" are 
final states.  

This transiton relation of the whole my_process process is:

     --a-->o--b-->o--c-->(F)
    /
-->o--b-->o--a-->o--c-->(F)
    \
     --b-->o--c-->(F)



forever
-------

The forever construct executes a process forever (or until a stop 
statement).  In the following process,

//------------------------------
process my_process {
    forever {
      choice {
            a;
            stop;
      };
    };
    b;
}
//------------------------------

the forever{..} subprocess has the following transition relation:

-->(F)--a--
    ^      \
    \      /
     -----

Hence the transition relation of my_process is:

     --b-->(F)
    /
 -->o--a---
    ^      \
    \      /
     ------


assume
------

The assume statement defines transition guard enforced by the 
environment.  It can occur at the start of a transition or 
anywhere inside of the transition.  

//------------------------------
process my_process {
   x=0;
   y=2;
   choice {
       {
           assume(x>0);
           y = x;
       };
       {
           assume(x<0);
           y = z;
       };
}
//------------------------------

Here, the initial transition initialises x to 0.  The process than 
waits until x becomes non-zero (e.g., after being modified by 
another process), which enables one of the two transitions inside 
the choice construct.  Note that although choice represents 
non-deterministic choice, it only chooses among enabled 
transition.  In this example at most one of the two transitions 
can be enabled at any time.

The assume construct can be used to implement process 
synchronisation mechanisms such as events, semaphores, waiting on 
a condition, etc.


assert
------

assert statements model safety constraints.  When a process performs a 
transition that contains a violated assertion, it ends up in an error state. 

//------------------------------
process my_process{
   write8(REG, val);
   assert(dev_baud==os_baud);
}; 
//------------------------------


if, do, while
-------------

These constructs have the normal C semantics.  They do not start a new 
transition.

function
--------

Functions represent atomic computations without side effects.  A 
function cannot modify state variables or start a new transition.  
It is allowed to read values of state variables.  Functions can be 
used for example inside assume and assert statements that must be 
side-effect-free

//------------------------------
function bool configured() {
    return (dev_baud == os_baud);
}
//------------------------------

procedure
---------

Procedures are similar to functions, except they are allowed to 
have side effects.

//------------------------------
procedure int<8> update_state{
    x=2;
    y=z;
    return y;
}
//------------------------------

task
----

A task represents a named process that can be instantiated from 
multiple other processes.  Task invocation always starts a new 
transition.  A task can have arguments and a return value (do we 
want in/out arguments?).  A task can have one of the following 
types: controllable/uncontrollable/invisible.  Only controllable 
tasks can be invoked from synthesised code.  

//------------------------------
controllable int<8> probe() {
    os_baud = 115200;
    write8(REG_BAUD,4);
    return 0;
};
//------------------------------

A task is terminated by return statement rather that stop.  A stop 
statement inside a task terminates the process containing the 
task.  

A return statement does not start a new transition.  Furthermore, 
it does not terminate the current transition, so that statements 
following task invocation can be executed as part of the final 
transition of the task.  For example,

//------------------------------
process my_process {
    ret = probe();
    if (ret != 0)
        stop;
    x=0;
}
//------------------------------

Here the write8 call inside the probe() task, the return from the 
task and the subsequent assignment (x=0) or task termination take 
place in a single transition.

Note: recursive invocations of functions, procedures and tasks are 
not allowed.

goal
----

A template can contain a list of named goals.  The syntax for 
goals is not defined yet.

{...}
-----

The {...} statement represents a block of code that must be 
synthesised.  It can have two forms.  The first form specifies a 
postcondition that must hold when the synthesised block 
terminates.  This postcondition is translated into an implicit 
goal and the goal synthesised for the block follows a strategy for 
this goal (while staying within the winning region for other 
goals).

//------------------------------
{...} post(configured());
//------------------------------

The second goal specifies a named goal instead of the 
postcondition.  

//------------------------------
task send(int<8> dat) {
    {...} using seng_goal;
}
//------------------------------

This means that the synthesised code will follow the strategy for 
the specified goal while staying within the winning set for other 
goals.  This does not guarantee that the system will be within the 
goal when the synthesised block terminates.  In this example, the 
send_goal goal can only be reached inside the interrupt handler, 
whereas the send() task only queues data to be sent in the future.

Thus the {...} construct allows the user to manually schedule 
goals, which seens necessary to produce sensible code.


@-statement
-----------

TODO

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Full TSL
========
