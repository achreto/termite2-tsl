\documentclass{report}

\usepackage{color}
\usepackage[usenames]{xcolor}
\usepackage{tikz}

\definecolor{lgray}{gray}{0.9}

\usepackage{listings}

\lstnewenvironment{tsllisting}[1]
{\vspace{3mm}
 \lstset{
    backgroundcolor=\color{lgray},
    basicstyle=\small\ttfamily, 
%    keywordstyle=\bfseries,
    keywordstyle=\underbar,
    identifierstyle=,
    commentstyle=\slshape,
    stringstyle=,
    showstringspaces=false,
    keywords={after,
              always,
              assert,
              assign,
              assume, 
              before,
              bool,
              case,
              choice, 
              cond,
              const,
              controllable, 
              default,
              derive,
              do, 
              else, 
              endtemplate,
              enum,
              export,
              false,
              forever, 
              fork, 
              function, 
              goal,
              if, 
              import,
              init,
              invisible, 
              mem,
              out,
              pause,
              break,
              post, 
              procedure, 
              process,
              return,
              sint,
              stop, 
              struct,
              task, 
              template, 
              true,
              typedef,
              uint,
              uncontrollable, 
              using, 
              void,
              while,
              wait},
    sensitive=false,
    morecomment=[l]{//},
    morecomment=[s]{/*}{*/},
    numberstyle=\tiny,
    stepnumber=1,
    numbersep=1pt,
    emphstyle=\bfseries,
    belowskip=0pt,
    aboveskip=0pt,
    #1
}}{\vspace{3mm}}

\lstnewenvironment{bnflisting}[1]
{\vspace{3mm}
 \lstset{
    backgroundcolor=\color{lgray},
    basicstyle=\small\ttfamily,
    keywordstyle=\underbar,
    identifierstyle=,
    commentstyle=\slshape,
    stringstyle=,
    showstringspaces=false,
    keywords=,
    sensitive=false,
    morecomment=[l]{//},
    morecomment=[s]{/*}{*/},
    numberstyle=\tiny,
    stepnumber=1,
    numbersep=1pt,
    emphstyle=\bfseries,
    belowskip=0pt,
    aboveskip=0pt,
    #1
}}{\vspace{3mm}}


\newcommand{\src}[1]{\texttt{#1}}

\newcommand{\tsl}{TSL2 }

\newcommand{\comment}[1]{{\textit{\textbf{#1}}}}


\author{Leonid Ryzhyk}

\title{\tsl Reference Manual}

\begin{document}

\maketitle

\tableofcontents

\chapter{Overview}

\section{Static and dynamic namespaces}\label{s:o:namespace}

\tsl supports two namespaces: the \emph{static namespace} and the 
\emph{dynamic namespace}.  The static namespace is populated with 
compile-time objects: \emph{types} and \emph{constants}.  The 
dynamic namespace is populated with runtime objects: 
\emph{processes}, \emph{variables}, \emph{methods}, and 
\emph{wires}.  Static objects are uniquely identified by their 
name and syntactic scope.  In contrast, runtime objects can be 
instantiated multiple times within the specification and hence 
must be referred to relative to their runtime scope.  

\section{Templates}\label{s:o:templates}

Templates are the principal mechanism for managing both static and 
dynamic namespaces.  A template models an entity, such as a 
device, an OS, or a device driver.  It declares a set of static 
objects (types and constants) and a set of runtime objects.  
Static objects declared inside a template can be referenced from 
any part of the specification via the template name.  Runtime 
objects are instantiated together with the template and can be 
accessed via a reference to a template \emph{instance}.

The following template declares type \src{word} (static object) 
and variable \src{x} (runtime object):
\begin{tsllisting}{}
template A
  // type declaration
  typedef uint<16> word;
  // variable declaration
  export word x;
endtemplate
\end{tsllisting}
The \src{word} type is globally visible via the \src{::}-notation 
as \src{A::word}.  It can be used even if template \src{A} is 
never instantiated.  In contrast, variable \src{x} can only be 
accessed via an instance of \src{A}.  

A template is instantiated inside another template.  The only 
exception is the \src{main} template, which is implicitly 
instantiated in the top-level scope.  Every complete \tsl 
specification must contain a template called \src{main}.  

In the following example, the \src{main} template creates an 
instance of \src{A}, making its variables accessible from 
\src{main} via instance name:
\begin{tsllisting}{}
template main
  instance A a;

  process pmain {
    // assigning variable x of template instance a.
    a.x = 16'd0;
  }
endtemplate
\end{tsllisting}

The template instantiation mechanism gives rise to an 
\emph{instance tree} with the \src{main} template as its root.  
Dynamic objects within the tree are accessed using hierarchical 
identifiers such as \src{a.x}.  This mechanism allows accessing 
objects down the branch of the instance tree, starting at the 
local template.  In practice, it is often necessary to access 
objects instantiated in other parts of the tree.  This is achieved 
in a structured way using \emph{template ports}.  

A template port is an alias to a template of a given type bound at 
the time of instantiation.  For example, template \src{B} below 
declares port \src{aa} of type \src{A}, which makes runtime 
objects in the scope of \src{A} visible from \src{B}.  Both 
templates are then instantiated in the \src{main} template, with 
the instance of \src{A} connected to port \src{aa} of \src{B}.
\begin{tsllisting}{}
// template B with port aa of type A
template B(A aa)
  process proc {
    aa.x = 16'd0;
  };
endtemplate

template main
  // create instances of A and B; connect port aa of
  // B to the instance of A.
  instance A a;
  instance B b(a);
endtemplate
\end{tsllisting}

The following diagram illustrates the resulting instance tree and 
the link between different branches of the tree via port \src{aa}.

\begin{tikzpicture}
    \node[rectangle] (m) at (0,1) {main};
    \node[rectangle] (a) at (-1,0) {main.a};
    \node[rectangle] (b) at (1,0) {main.b};
    \path[->] (m) edge (a);
    \path[->] (m) edge (b);
    \path[->,dashed] (b) edge node[auto]{aa} (a);
\end{tikzpicture}

Another mechanism for managing name spaces is \emph{template 
inheritance}.  Using inheritance, one can create generic templates 
that capture common properties of a family of entities, leaving 
some of the properties underspecified.  The generic template can 
be specialised by a child template that fills in the missing 
details.  For example, the following template models common 
device-class callbacks that must be implemented by any OS 
specification for the IDE device class.  Note that callbacks are 
defined without bodies, as the exact behaviour is OS-specific.
\begin{tsllisting}{}
template ide_os
  procedure void write_sectors(uint<48> lba, 
    uint<16> sectors, uint<32> buf, bool xfer_error);
  procedure void read_sectors(uint<48> lba, 
    uint<16> sectors, uint<32> buf, bool xfer_error);
  procedure void reset();
  ...
endtemplate
\end{tsllisting}
This template is specialised by the \src{l4\_ide\_os} template,
that describes the IDE driver interface defined by the seL4 OS.
\begin{tsllisting}{}
template l4_ide_os(l4_ide_drv drv)
  // the derive statement is used to establish the 
  // inheritance relation
  derive ide_os;

  // additional specification items can be declared in the 
  // child template
  export iostatus reset_status = ionone;

  // the child template implements methods inherited from 
  // the parent.
  procedure void write_sectors(uint<48> lba, 
    uint<16> sectors, uint<32> buf, bool xfer_error)
  {
    assert (lba == r_lba);
    ...
  }
\end{tsllisting}


\section{Execution model}

All state transitions in \tsl occur in the context of 
\emph{processes}.  Multiple processes can be enabled at the same 
time; however exactly one process participates in each individual 
transition.  Processes are declared inside templates using the 
\src{process} keyword.  Such processes become runnable in the 
initial state of the specification.  Additional processes can be 
spawned at runtime using the \src{fork} construct.  Syntactic 
constraints of the language (namely, the lack of support for 
recursion) guarantee that only a bounded number of processes can 
be spawned at any time.  

In the following example, template \src{A} contains a single 
static process \src{psndrcv}, which spawns two subprocesses 
\src{psend} and \src{preceive}.
\begin{tsllisting}{}
template A

process psndrcv {
  fork {
    psend:    while (true) send();
    preceive: while (true) receive();
  };
  shutdown();
};
...

endtemplate
\end{tsllisting}

%In addition to statically and dynamically created processes, every 
%\tsl specification contains an implicit \emph{idle} 

A process state transition starts in the current program location 
and stops at the next \emph{pause location}.  Pause locations can 
be explicit or implicit.  Explicit pause locations are declared 
using \src{pause}, \src{wait}, and \src{stop} constructs.  
Implicit pause locations are introduced automatically by the 
compiler in the following cases:

\begin{itemize}
    \item Before \src{fork} statements~\ref{}
    \item Before magic blocks~\ref{}
    \item On entries to and exits from controllable and 
        uncontrollable tasks~\ref{}
\end{itemize}

Process behaviour can be factored into \emph{methods}.  A process 
can invoke methods declared inside its own template as well as in 
other template instances, via hierarchical identifiers discussed 
in the previous section.  There are three types of methods in 
\tsl: \emph{functions}, \emph{procedures}, and \emph{tasks}.  
Functions and procedures must complete instantaneously, i.e., they 
are not allowed to contain explicit or implicit pauses.  In 
addition, functions are not allowed to have side effects, i.e., 
they cannot modify any global variables, perform pointer 
dereferences, or contain assertions (pointer dereferences and 
assert statements can have the side effect of taking the system 
into an error state).  

Tasks can take time to execute.  A task can have an optional 
\src{controllable} or \src{uncontrollable} qualifier.  
Controllable tasks are the only kind of task that can be invoked 
from synthesised code; although they can also be called from 
manually written code.  They are used to model the device register 
interface and OS callbacks.  Controllable tasks are subject to 
additional implementation constraint.

Uncontrollable tasks represent driver methods invoked by the OS or 
the device.  Uncontrollable tasks are the only kind of task that 
can contain automatically generated code, i.e., a magic block can 
only be placed inside an uncontrollable task.  

Controllable and uncontrollable task invocations introduce 
implicit pause locations on entry and return from the task.  In 
the following example execution of process \src{p1} will consist 
of three transitions.
\begin{tsllisting}{}
template A
  uint<16> x;

  process p1 {
    x=1;
    t1(x);
  };

  task uncontrollable void t1(uint<16> arg) {};
endtemplate
\end{tsllisting}
The first transition assigns global variable \src{x} and sets the 
argument of task \src{t1} to be equal to \src{x}.   An implicit 
pause location is inserted at this point.  The second transition 
executes the body of task \src{t1}, which completes 
instantaneously, as it does not contain any pause locations.  
Another implicit pause is inserted at the task return location.  
The remainder of the process is executed in the third transition.  
Note that other processes can run and potentially modify variable 
values in between transitions 1 and 2 and transitions 2 and 3.

Tasks without \src{controllable} and \src{uncontrollable} 
qualifiers behave as if the body of the task was inlined at the 
call location.  No additional pauses are inserted before or after 
the task.

\section{Variables and wires}

\emph{Variables} are used to store state that persists for the 
lifetime of the variable.  Variables in \tsl can be declared in 
the template, process, or method scope.  Template-scope variables, 
also called \emph{global variables}, are instantiated together 
with the template and are visible from anywhere inside the 
template.  In addition, variables declared with the \src{export} 
qualifier can be accessed from other templates via their 
hierarchical identifiers.  Process and method variables are only 
visible within the syntactic scope of the process or method where 
they are declared.

In contrast to variables, \emph{wires} are simply aliases to 
expressions defined over global variables and are not allocated 
their own storage.  Wires keep their values throughout a 
transition and are updated at the end of the transition.  Initial 
value of a wire is computed based on initial values of global 
variables.

\begin{tsllisting}{}
template A
  uint<16> x = 0;
  wire uint<16> w = x + 1;
endtemplate
\end{tsllisting}


\section{Correctness specifications}\label{s:o:correctness}

\tsl provides several mechanisms for specifying correctness 
conditions over system behaviour:
\begin{itemize}
    \item \emph{Goals.} A goal is a boolean expression over global 
        variables that must hold infinitely often in any infinite 
        run of the system.  A template can declare any number of 
        goals.  In addition, \tsl defines two implicit goals.  The 
        first one requires the system to be outside of a magic 
        block infinitely often; in other words, the system cannot 
        stay inside a magic block forever.  The second implicit 
        goal requires that the system never enters an \emph{error 
        state} (see below).
    \item \emph{Assertions.}  An \src{assert} statement can be 
        placed anywhere inside processes, tasks, and procedures.  
        It defines a condition whose violation immediately 
        transitions the system to an error state.
    \item \emph{Postconditions}.  Magic block postconditions are 
        discussed in Section~\ref{s:o:magic} above.
\end{itemize}



\section{Magic blocks}\label{s:o:magic}

A \emph{magic block} is a place holder for automatically generated 
code.  \tsl supports two types of magic blocks.  Magic blocks with 
\emph{postconditions} specify a condition that must hold upon 
returning from the magic block.  

%Note that for synthesis to succeed the resulting system must 
%satisfy all correctness conditions described in the following 
%section, and not just magic block postconditions.

\begin{tsllisting}{}
template main
  task uncontrollable bool probe() {
    // Magic block with postcondition
    {...} post((os.reset_status == iosuccess) ||
               (os.reset_status == ioerror));
    if (os.reset_status == iosuccess) {
      return true;
    } else {
      return false;
    };
};
endtemplate
\end{tsllisting}

The second type of magic blocks are magic blocks with 
\emph{goals}.  These are needed because not all correctness 
conditions can be captured using postconditions and assertions.  
For correctness conditions specified using goals (see 
Section~\ref{s:o:correctness}), the synthesis algorithm computes a 
strategy for each goal; however the scheduling of strategies is 
left to the user, i.e., the user decides when to execute each 
strategy by assigning goals to magic blocks. \comment{TODO: I 
still have not figured out the exact meaning of this construct.}

%\section{Constraints on the environment}

\chapter{Syntax reference}

\section{Literals}\label{s:r:literals}

\tsl supports boolean literals ``\src{true}'' and ``\src{false}'' 
and Verilog-style binary, octal, decimal and hexadecimal integer 
literals.  The exact number of bits can be specified for each 
integer literal.  

\begin{bnflisting}{}
<intLit> := <decNumber>
          | [<width>] "'b"  <binNumber>
          | [<width>] "'sb" <binNumber>
          | [<width>] "'o"  <octNumber>
          | [<width>] "'so" <octNumber>
          | [<width>] "'d"  <decNumber>
          | [<width>] "'sd" <signedDecNumber>
          | [<width>] "'h"  <hexNumber>
          | [<width>] "'sh" <hexNumber>
<width> := <decNumber>
\end{bnflisting}

Examples of integer literals:
\begin{tsllisting}{}
uint<8> x;
sint<8> y;

x = 255;
x = 8'd35;
x = 8'b01010101;
x = 8'b1;

y = 8'sb11111111;
y = 8'sd-6;
\end{tsllisting}

In case literal width is not specified explicitly, the compiler 
assumes width sufficient to encode the given integer value, for 
example literal $5$ is assumed to be $3$ bits wide, as $3$ bits 
are sufficient to encode values between $0$ and $5$.  The compiler 
does not perform automatic truncation or extension of integers.  
For example, the following assignment statement is invalid, as the 
left and the right-hand sides of assignment have different width:

\begin{tsllisting}{}
uint<8> x = 0; // error: x has width 8, while
               // literal 0 has widt 1

uint<8> y = 8'd0; // ok
\end{tsllisting}


\section{Identifiers}\label{s:r:identifiers}

Identifiers are used throughout \tsl specification to refer to 
static and runtime objects (Section~\ref{s:o:namespace}).  \tsl 
supports three forms of identifiers:

\paragraph{Simple identifiers.}  A simple identifier is a name of 
a static or runtime object visible within the current syntactic 
scope.  This includes objects declared within the current scope or 
in one of its parent scopes.  For example, simple identifier 
\src{x} used in a method body can refer to a local variable or 
argument of the method, template-global variable, or a type or 
constant declared in the template or top-level scope.

\begin{bnflisting}{}
<ident> := (<letter> | "_") (<letter> | <digit> | "_")*
\end{bnflisting}

\paragraph{Static scoped identifiers.} These identifiers refer to 
static objects declared within template scope.  They can be used 
to refer to static objects declared in templates other than the 
local template.

\begin{bnflisting}{}
<staticIdent> := <ident> "::" <ident>
\end{bnflisting}

\paragraph{Hierarchical identifiers.}  These identifiers can only 
be used to refer to runtime objects.  A dynamic identifier is a 
dot-separated sequence of literals that traverses the instance 
tree (Section~\ref{s:o:templates}) via port and instance names:

\begin{bnflisting}{}
<dynIdent> := <ident> ["." <ident>]*
\end{bnflisting}

The following example illustrates the use of different types of 
identifiers.

\begin{tsllisting}{}
template A
  typedef uint<16> word;
  export word x;
endtemplate
    
template B(A aa)
  // Reference to the word type declared in template A
  // via static scoped identifier;
  A::word y;

  process proc {
    // In the following statement:
    // * y is a simple identifier that refers to a variable
    //   declared in the local template
    // * aa.x is a hierarchical identifier that refers to
    //   variable x declared in template A.
    y = aa.x;
  };
endtemplate

template main
  // create instances of A and B; connect port aa of
  // B to the instance of A.
  instance A a;
  instance B b(a);
endtemplate
\end{tsllisting}


\section{Types}

Type expressions can occur in various contexts in a \tsl 
specification, including variables, method, wire, type, and 
constant declarations.  The language currently supports arbitrary 
fixed-width signed and unsigned integers, booleans, enums, 
structs, arrays, and pointers.

\begin{bnflisting}{}
<typeSpec>   := ( <sintType>    // signed int
                | <uintType>    // unsigned int
                | <boolType>    // boolean
                | <userType>    // user-defined type name
                | <enumType>    // enumeration
                | <structType>) // struct
                <typeModifier>* // type modifiers

<sintType>   := "sint" "<" <decimalNumber> ">"
<uintType>   := "uint" "<" <decimalNumber> ">"
<boolType>   := "bool"
<userType>   := <staticIdent>
<enumType>   := "enum" "{" (<ident> ",")*  <ident> "}"
<structType> := "struct" "{" (<typeSpec> <ident> ";")+ "}"

// A type modifier is either array dimension or the pointer
// modifier ("*")
<typeModifier> := ("[" <expr> "]")
                | "*"
\end{bnflisting}

\tsl enum's are different from C-style enum's in that they are not 
integers.  In particular, a variable of enum type cannot be cast 
to an integer.  Such a variable can only take one of the values in 
the enumeration and not any other arbitrary integer value.  
Furthermore, an enum declaration cannot assign integer values to 
enumerators.

Type expressions are subject to the following constraints:
\begin{itemize}
    \item Enumerations can only be declared in \src{typedef}
        statements, e.g., they cannot be used in variable or 
        method declarations.  This ensure that every enum type has 
        a name.
    \item Variable-size arrays are not supported: array dimensions 
        must be compile-time constants.
\end{itemize}

Examples of type expressions:

\begin{tsllisting}{}
typedef uint<16> t1;
typedef sint<13> t2;
typedef enum {e1, e2, e3} t3;
typedef struct {t1 f1; t2 f2;} t4;
const t1 c1 = 16'd5;
typedef t4[c1] arrtype;
typedef struct {bool f1; uint<16>[10] f2;} * structptr;
\end{tsllisting}


\section{Expressions}

\tsl expressions are constructed from identifiers 
(Section~\ref{s:r:identifiers}), literals
(Section~\ref{s:r:literals}), and method applications~\ref{} using 
operators summarised in the following table in the order of 
decreasing precedence.

\begin{small}
\noindent
\begin{tabular}{|l|l|l|l|p{0.3\linewidth}|}
    \hline
    {\bf operator}                   & {\bf syntax} & {\bf arg type} & {\bf res type} & {\bf comment} \\
    \hline
    \hline 
    {\tt[:]}                         & {\tt e[l:h]} & integer        & integer        & bit slice \\
    {\tt[~]}                         & {\tt e[i]}   & array          & -              & array index \\
    {\tt.}                           & {\tt e.f}    & struct         & -              & struct field \\
    {\tt\verb=->=}                   & {\tt\verb=e->f=}  & struct pointer & -              & struct dereference \\
    \hline
    \src{!}                          & prefix  & bool           & bool           & boolean negation \\
    {\tt\verb=~=}                    & prefix  & integer        & integer        & bit-wise negation \\
    {\tt-}                           & prefix  & integer        & integer        & unary minus \\
    {\tt*}                           & prefix  & pointer        & -              & pointer dereference \\
    {\tt \&}                         & prefix  & any            & pointer        & address-of \\
    \hline
    {\tt ==, !=}                     & infix   & any            & bool           & \\
    {\tt\verb#<, <=, >, >=#}         & infix   & integer        & bool           & \\
    \hline    
    {\tt\&}                          & infix   & integer        & integer        & bit-wise and \\
    \hline    
    {\tt |}                          & infix   & integer        & integer        & bit-wise or \\
    \hline    
    {\tt\verb#^#}                    & infix   & integer        & integer        & bit-wise xor \\
    \hline    
    {\tt\&\&}                        & infix   & bool           & bool           & boolean and \\
    \hline    
    {\tt||}                          & infix   & bool           & bool           & boolean or \\
    \hline    
    {\tt\verb#=>#}                   & infix   & bool           & bool           & boolean implication\\
    \hline    
    {\tt*}                           & infix   & integer        & integer        & multiplication \\
    \hline    
    {\tt\%}                          & infix   & integer        & integer        & residue \\
    \hline    
    {\tt+}                           & infix   & integer        & integer        & plus \\
    \hline    
    {\tt-}                           & infix   & integer        & integer        & minus \\
    \hline
\end{tabular}
\end{small}

In addition, \tsl supports three kinds of conditional expressions: 
\src{if-else} expressions (or ternary expressions), 
\src{case}-expressions, and \src{cond}-expressions.  

\begin{bnflisting}{}
<ternExp>  := "if" <expr> <expr> "else" <expr>
<caseExp>  := "case" "(" <expr> ")" "{" 
                  (<expr> ":" <expr> ";")* 
                  ["default" ":" <expr> ";"]
              "}"
<condExp> := "cond" "{"
                  (<expr>    ":" <expr> ";")*
                  ["default" ":" <expr> ";"]
              "}"
\end{bnflisting}

A \src{case}-expression chooses a value based on the value of its 
key expression, whereas a \src{cond}-expression chooses a value to 
return by evaluating a series of conditions in order.  Note that 
\src{if-else} expressions are different from \src{if} statements 
described in Section~\ref{}.

Finally, \tsl supports struct expressions with explicit or implicit 
field names:

\begin{bnflisting}{}
<structExp>   := <staticIdent> "{" 
                     (<namedFields> | <anonFields>) 
                 "}"
<namedFields> := "." <ident> "=" <expr> 
                 [("," "." <ident> "=" <expr>)*]
<anonFields> := <expr> 
                 [("," <expr>)*]
\end{bnflisting}

Note that \tsl does not provide type casting operations.  In 
particular, it is impossible to convert a pointer to an integer or 
an integer to a pointer.  In addition, the \tsl compiler enforces the 
following type and memory safety rules:
\begin{itemize}
    \item No arithmetic operations are allowed on pointers
    \item Bit-wise operators must be applied to integer operands 
        of the same width
    \item \src{==} and \src{!=} operations can only be applied to 
        operators of identical types (including width and 
        signedness)
    \item Labels in a \src{case}-expression and conditions in a 
        \src{cond}-expression must be side-effect free
    \item All branches of a \src{case}, \src{cond}, or \src{if-else}
        expression must return values of the same type
    \item Lower and upper bounds of a bit slice must be constant 
        expressions, lower bound must be less than or equal to the 
        upper bound, and both bound must be smaller than the width
        of the argument.
\end{itemize}

\section{\tsl file structure}

A \tsl file consists of \emph{import} statements, type 
declarations, constant declarations, and template declarations.

\begin{bnflisting}{}
<tslFile>  := <specItem>*
<specItem> := <import>
           |  <typedecl>
           |  <const>
           |  <template>
\end{bnflisting}

\section{Import statements}

Import statements are used to combine multiple \tsl files into a 
single specification.  They are only allowed in the top-level 
syntactic scope, i.e., they are illegal inside template of type 
declarations.  An import statement consists of the \src{import} 
keyword followed by file path in angle brackets:
\begin{tsllisting}{}
import<ide_dev.tsl>
import<os/ide_tsl2/l4_ide.tsl>
import<../../os/ide_tsl2/ide_class.tsl>
\end{tsllisting}
The \tsl compiler appends this path to each import directory, 
specified via the \src{-I} command line switch, in order, until a  
file with this name is found.


\section{Templates}

Templates must be declared within the top-level scope, i.e., 
nested template declarations are not allowed.  Template 
declaration has the following syntax:
\begin{tsllisting}{}
template <template-name>[(<port-declarations>)]
  <template-item>*
endtemplate
\end{tsllisting}



\end{document}
