We define sematics of basic TSL by specifying translation from TSL 
to A2L (or whatever we call the "old TSL" these days).  

Simplifying assumptions (can be statically checked on the TSL 
program before compiling it):
* All controllable tasks complete in a single transitions, i.e., 
  there cab be no delays inside an uncontrollable task.  This
  holds in all examples we've seen so far, e.g., register
  read/write methods complete in a single transition.  This
  simplification allows us not to worry about return transitions
  from controllable tasks, since call and return happen
  instantaneously.

1. Overview
===========

In translating a TSL spec to A2L, we split it into the following 
types of atomic transitions:
- Uncontrollable task calls - transitions triggered by the OS 
  calling an uncontrollable task (a driver interface method).    
  Such a transition has an uncontrollable tag that corresponds to 
  the name of the task and uncontrollable label variables that 
  represent input arguments of the task.  
- Controllable manual task call - transitions triggered by calls 
  to controllable tasks (e.g., read8/write8/send_complete) that   
  are specified manually in the template.  Such transitions are   
  modelled as _un_controllable transitions, since synthesised code   
  does not have any influence over them.  Such a transition has an 
  uncontrollable tag and no additional label variables, because 
  arguments of the invocation are computed as functions of state 
  variables.
- Anonymous transitions - transitions started by pause or stop 
  statements rather than by a task call.  Such transitions can be 
  visible or invisible depending on the scope in which they are 
  started.  Anonymous transitions are identified by an 
  uncontrollable tag, e.g., anon1, anon2, ...
- Controllable transitions - calls to controllable tasks that can 
  occur from synthesised code.  One such transition is generated 
  for every controllable task, in addition to controllable manual 
  transitions described above.  It has a controllable tag (which 
  is distinct from tags used to model manual invocations of the 
  same task) and controllable label variables that model its  
  arguments.  One additional type of controllable transition is 
  return from magic block.  This transition is generated by the 
  synthesis algorithm when the synthesised strategy requires 
  returning control to manually written code.

TSL to A2L translation consists of the following steps:

1. Method inlining - the specification is flattened by inlining
   method bodies
2. Source code ==> Control Flow Automaton (CFA)
3. CFA ==> Labelled Transition Systems (LTS)
4. LTS ==> A2L

2. Process tree
===============

A TSL2 program consists of processes, including processes declared 
using the "process" keyword and processes spawned using the fork 
construct.  The set of all processes can be described by the 
process tree, where nodes correspond to processes and edges model 
parent-child relations among processes. 

Consider the following template:

template test

bool dummy1;
bool dummy2;

process p1 {
    t1();
};
process p2 {
};
task void t1() {
    probe();
    fork{
        send:    send_task();
        receive: dummy2 = receive_task(true);
    };
}
task bool receive_task(book arg) {
    uint<8> x;
    return x;
};
endtemplate


This template has the following process tree:

                   |
        --------- test -----------------
        |                              |
  ----- p1 -----                      p2
  |            |
send        receive


Note that in general the process tree can contain multiple nodes 
corresponding to the same syntactic process, e.g., if the task 
that spawns the process is invoked from multiple other processes.

In a well-formed TSL2 program the process tree must be finite, 
meaning that the set of processes can be determined statically.  

3. Preprocessing
================

The preprocessing step transforms all expressions in the template 
to a form where function calls only occur at the top level of the 
expression.  This may require introducing auxiliary variables.

Examples:

x = y + f(z)  ==>  tmp = f(z); x = y + tmp;
x = f(y+z)    ==>  tmp = y+z; x = f(tmp);


4. A2L variables
================

This section lists A2L variables generated during the TSL-to-A2L 
translation.  The use of these variables is explained in more 
detail in the following sections.

Tags
----

Controllable and uncontrollable tags are generated as described in 
Section 1.  

- Uncontrollable tags are introduced for uncontrollable task  
  calls, controllable manual task calls, and anonymous  
  transitions.
  
- Controllable tags are generated for controllable tasks.

- An additional controllable tag is generated for the return from 
  magic block transition.

Label variables
---------------

* Uncontrollable label variables - generated for uncontrollable
  task arguments.

* Controllable label variables - generated for controllable task
  arguments.

* Outcome variables - generated for return values and out 
  variables of controllable tasks

* An additional label variable is introduced to identify the
  process (i.e., the node in the process tree) in the context of
  which the transition is taking place.

State and tmp variables
-----------------------

The state space of a TSL2 program consists of the following 
variables:

* Global template variables
* Process-local variables.  An instance of process-local variables 
  is introduced for each node in the process tree.
* Task-local variables.  Task-local variables include formal input 
  arguments and variables declared within task scope.  Since TSL2
  does not allow recursion, at most one instance of a task can be
  active in each node of the process tree, hence we need to create
  at most one instance of task-local variables for each process in
  the process tree.

  Note: input arguments of the task can be declared both as
  state/temporary variables and as label variables (see above).  

Temporary variables
* Function and procedure local variables are translated into temp 
  variables in A2L

Optimisations:
* State variables whose values are not used across multiple 
  transitions can be demoted to temporary variables.  
* A task that completes in a single transition only requires a 
  single copy of local variables that can be demoted to temporary
  variables.

Program counter variables:
* For each process in the process tree we introduce a state 
  variable that acts as program counter for the process.

Magic block indicator variable:
* Additional state variable is used to indicate that the system 
  is inside a magic block and to identify the magic block.  It 
  guarantees that at most one magic block can be active at a time.  
  Controllable actions can only be performed inside the magic 
  block.


5. Method inlining
==================

At this step, all functions, procedures, and tasks are recursively 
inlined, with references to local variables being replaced with 
references to corresponding A2L state and temporary variables.

Inlining of method bodies is performed in every node of the 
process tree, and for every call site.  


The actual method inlining proceeds as follows:
* References to method-local variables are replaced with
  references to corresponding A2L variables.  
* actual input arguments are replaced with assignments to 
  corresponding A2L state or tmp variables.
* for uncontrollable tasks:
  - insert pause statement before the body of the task
  - generate assignment to uncontrollable tag corresponding to the 
    task name
  - generate assignments to uncontrollable label variables that 
    represent task arguments
* for controllable manual tasks:
  - insert pause statement before the body of the task
  - generate assignment to the uncontrollable tag
* replace each return statement with an assignment to the lhs 
  expression of the method invocation statement, followed by a
  goto to the statement immediately following the invocation
* assignments to output arguments are replaced with assignments
  to l-expressions passed as actual arguments to the method

In addition, the content of all controllable tasks is inlined in a 
similar way.  

The result of this step is a specification in the intermediate 
format that consists of only processes and controllable tasks that 
manipulate state, label, and tag variables declared at the top 
level.

6. Source code ==> Control Flow Automaton (CFA)
===============================================

At this step, each process in the process graph and each 
controllable task is translated into an intermediate CFA 
representation.  States of the CFA correspond to program 
locations, plus additional error state; transitions correspond to 
program instructions.  Note that CFA transitions do not match 
one-to-one atomic state transitions of the system: a single atomic 
transition can consist of multiple CFA transitions.  The CFA 
contains the following types of transitions:

- assignments
- assume statements
- pause
- stop
- magic blocks
- fork blocks

Below we show how the various control flow constructs are 
translated into CFA.

if-else
-------

if(cond) {
  block1;
} else {
  block2;
};
block3;


choice
------

choice{
   block1;
   block2;
};
block3;

      --assume(true)-->o--block1--
    /                             \
-->o                                o---block3-->
    \                             /
      --assume(true)-->o--block2--


assert
------

assert(cond);
block1;


-->o--assume(cond)-->o--block1-->
    \
      --assume(!cond)-->E

where E is the error state


loops
-----

while (cond) {
    block1;
};
block2;

     ---block1-----
    /              \
-->o--assume(cond)->o
    \
      --assume(!cond)-->o---block2-->
      

do {
    block1;
} while (cond);
block2;

     -assume(cond)-
    /              \
-->o-----block1---->o--assume(!cond)-->o---block2-->

for(st1;cond;st2) {
    block1
};
block2;

              -------------st2-----------
             /                           \
-->o--st1-->o--assume(cond)-->o--block1-->o
             \
              --assume(!cond)-->o-->block2-->


break
-----

while(cond1) {
    ...
    if(cond2) break;
    ...
};
block2;


     ----...----<--assume(!cond2)-
    /                             \
-->o--assume(cond1)->o----...----->o--assume(cond2)--
    \                                                \
     --assume(!cond1)-------------------------------->o---block2-->


7. CFA ==> Labelled Transition Systems (LTS)
============================================

CFAs obtained at the previous step for each process in the process 
graph and each controllable task are translated into labelled 
transition systems (LTS).  LTS transitions correspond to atomic 
transitions of the system.  The LTS has a single initial state, 
potentially multiple final states, and a single error state.

LTS states correspond to a subset of CFA states, namely those 
states where the CFA reaches the end of atomic transition.

Definition: CFA transitions labelled with assignments and assume
statements are called instantaneous transitions.  All other 
transitions (labelled with stop, pause, magic blocks, and fork 
blocks) are non-instantaneous transitions.

Assumption: a well-formed CFA does not contain infinite sequences 
of instantaneous transitions.

LTS construction algorithm:

1. Compute initial state of LTS.  Consider initial state of the 
   CFA.  Compute the maximal sequence (possibly empty) of pause 
   and stop transitions from this state.  By construction of CFA, 
   there exists exactly one such sequence.  Add the final state of 
   the sequence as initial state to LTS.  If at least one 
   transition in the sequence is a stop transition, mark initial 
   state as final.  If there are no enabled outgoing transitions 
   from the initial state, label the state as final.

2. Pick an LTS state that has at least one enabled outgoing 
   transition.  If no such state exists, the algorithm terminates.  
   Otherwise, consider two possible cases:
   1. If the selected state has either only enabled instantaneous 
      transitions or a single pause or stop transition, compute 
      the set of all _maximal_ sequences of instantaneous 
      transitions from the state (by the above assumption, all 
      such sequences must be finite) followed by a maximal 
      sequence of pause and stop transitions.  Each resulting 
      sequence represents a single transition of the LTS.  
      Instantaneous transitions in the sequence represent variable 
      assignments and guard conditions of the transition.  For 
      each sequence, add its final state to LTS.  Add transition 
      from the current state to the new state to LTS.  Transition 
      label is the concatenation of all instantaneous transition 
      labels along the path.  If at least one stop transition was 
      encountered along the path, label the new state as final 
      state.

      Optimisation: the above procedure can result in a large 
      number of transitions, as the number of program paths 
      between two program locations can be exponential in the 
      number of sequential if-else blocks between these locations.  
      A better algorithm would generate a single transition for 
      each final state and tag, combining all relevant branch 
      conditions along multiple paths.  (I don't have an algorithm 
      for doing this)

   2. If the state has a single outgoing magic transition or fork 
      transition, compute a sequence consisting of this transition 
      followed by the maximal sequence of pause and stop 
      transitions.  Add the final state of the sequence to the 
      LTS.  Add transition from the current state to the new state 
      to LTS.  If at least one stop transition was encountered 
      along the path, label the new state as final state.  

   Note that by construction of CFA, the above two cases cover all 
   possible situations.

   For each newly added state that does not have enabled outgoing 
   transitions, label the state as final.  If a state 
   corresponding to the same CFA state already existed in the LTS 
   and its final attribute had the same value as the newly added 
   state, merge the two states.

3. Goto step 2


The above procedure is applied to both processes and controllable 
tasks.  In case of controllable tasks, an additional 
transformation is applied to the resulting LTS: its final states 
are merged with the initial state, indicating that the task can be 
invoked multiple times.  Since a controllable task is required to 
complete in a single transition, the resulting LTS consists of two 
states: the initial state and the error state.  Finally, a 
controllable task invocation transition requires additional guard 
condition: assume(magic_block!=0), i.e., controllable tasks can 
only be invoked inside a magic block.


8. LTS ==> A2L
==============

Each LTS generated for a process in the process tree or a 
controllable task is converted to a set of A2L transitions.  To 
this end, we generate a program counter (PC) state variable for 
each process.  The domain of the variable contains a unique value 
for each state of the LTS, including the error state.  Dynamically 
spawned processes have additional PC value that represents 
inactive state.  This state is entered when the first transition 
following the fork block is taken.

The LTS is simplified by encoding fork and magic transitions with 
equivalent assign and assume statements.  In the resulting 
simplified LTS all transition labels consist of assume statements 
and variable assignments.


Magic transitions
~~~~~~~~~~~~~~~~~

In order to encode magic block transitions, we assign unique 
non-zero id's to all magic blocks in the process tree.  A special 
state variable called magic_block holds the id of the currently 
active magic block.  Value zero means that no magic block is 
currently active.

Consider a transition from state s1 to state s2 labelled with a 
magic block with postcondition cond:

     a                  {...}post(cond)
-------------------->o------------------->o--->
                     s1                   s2

We modify all transitions that enter state s1 to update the 
magic_block variable.  The magic transition itself is replaced 
with a pair of transitions.  The first transition, from s1 to s2 
is triggered by the end_magic controllable tag when postcondition 
cond holds.  This transitions assigns magic_block variable to 0.  
The second transition from s1 to the error state is also triggered 
by end_magic and is taken if the postcondition is violated:

   a;                   assume(ctag == end_magic);
   magic_block=m1;      assume(cond);
                        magic_block=0;
-------------------->o------------------->o--->
                    s1\                   s2
                       ------------------------>E
                          assume(ctag = end_magic);
                          assume(cond);

Fork transitions
~~~~~~~~~~~~~~~~

Consider a transition from state s1 to state s2 labelled with a 
fork block:

     a1                  fork{p1;p2;}        a2
-------------------->o------------------->o-------->o
                     s1                   s2        s3

We modify all transitions that enter state s1 to activate spawned 
processes by setting their PC variables to respective initial 
states.  The fork transition itself is eliminated:


     a1                                      a2
     p1.pc=p1_init;
     p2.pc=p2_init;
-------------------->o                    o-------->o
                     s1                   s2        s3


Next, we clone all outgoing transitions from state s2 in state s1 
and add extra constraints to these transitions to ensure that the 
transition is only enabled if all spawned processes are in their 
final states.  We also deactivare the spawned processes by setting 
their PC variables to inactive state:
  
   a1;                  assume(p1.final);
   p1.pc=p1_init;       assume(p2.final);
   p2.pc=p2_init;       p1.pc = inactive;
                        p2.pc = inactive;
                        a2;
-------------------->o------------------->o
                     s1                  /s3
                                        /
                     o------------------
                     s2       a2

where p1.final and p2.final are predicates over PC variables of p1 
and p2 that are true when the process is in a final state.

In the resulting LTS, some of the transitions correspond to 
controllable or uncontrollable task invocations, while other 
transitions are started by pause or stop statements.  In the 
former case, the transition contains a tag that corresponds to 
task name.  The latter kind of transition don't have tags.  We 
therefore generate unique uncontrollable tags for such anonymous 
transitions and add them to the LTS.  Tags are unique to a 
syntactic process, rather than a process tree node.

We are now ready to directly translate each LTS transition to an 
A2L transition with the following components:

- Transition tag is derived directly from the LTS transition
- The process_id label variable is assigned to a unique id of the 
  current process tree node (except for controllable task 
  transitions, which can be invoked from any process).
- Previous and next-state values of the program counter variable 
  correspond to the source and target states of the LTS.
- transition guards and variable assignments are extracted from 
  the LTS label.  This requires converting the label to the static 
  single assignment form and introducing temporary variables to 
  hold intermediate variable values.

Transitions to the error state require special treatment.  We want 
such transitions to disable all transitions in all processes in 
the system.  One way to achieve this is to update all PC 
variables, not just the local one, to their respective error 
states.

The exact encoding of the A2L transition is 
implementation-dependent and can be in the variable assignment 
form or in transition form.

In order to obtain a complete transition relation, we conjoin
the relation computed above with a relation that represents 
continuous assignments, where the right-hand side of a continuous 
assignment is computed over previous-state versions of state 
variables, while the left-hand side is replaced with its 
next-state version.

Other components of the A2L specifications are also directly 
extracted from the LTS or from the original TSL2 spec, in 
particular:

- Invisible transitions are anonymous transitions triggered 
  outside the context of uncontrollable tasks, described by the 
  disjunction of corresponding tags.
- Fair transitions include all process transitions, i.e., an 
  enabled process transition is taken eventually.
- Goals are taken directly from the TSL2 spec.  One additional 
  goal is defined implicitly: magic_block=0.  This goal requires 
  eventually exiting each magic block.
- The init section is generated based on TSL2 init blocks and 
  default variable values:
  - the magic_block variable is initialised to 0
  - PC variables are initialised to initial state for processes 
    that are statically enabled and to inactive state for forked 
    processes, with the exception of forked processes that are 
    spawned in the initial state of the parent process.  These 
    processes also start in initial states.
  - process-local and task-local variables are initialised to 
    their default values.  Variables whose default values are not 
    explicitly specified are initialised to 0.  
  - template-global variables are constrained by init blocks and 
    explicitly defined initial values only (i.e., no 
    initialisation to 0 by default)
